To ensure optimal positioning, the game must be executed in a terminal with a height of 45 and a width of 177. The total development time spanned 12 days, with varying workloads, some days involving minimal effort, while others required up to 7-8 hours of work.

Initially, the function "initialize_board" was used to set all game elements to zero. The "initial_numbers" function is called only once and is responsible for generating two random numbers (either 2 or 4) at random positions. First, a random position is generated, and since the board is empty, the random number is placed there. Subsequently, another position is generated, ensuring it does not coincide with the first number's position. Once verified, the while loop exits, and either a 2 or 4 is placed in the second position.

The "date" function is a simple mechanism, creating a `time_t` variable (t) and calling the `time` function to modify the variable in memory, which returns the number of seconds since January 1, 1970. Using the time structure, details such as day, month, year, etc., can then be displayed. The "random_number" function is invoked whenever a valid move occurs, following the logic described for the "initial_numbers" function. A random position is generated, checked for availability, and then either a 2 or 4 is placed at that position.

The functions "move_left," "move_right," "move_down," and "move_up" operate on the same principle. As an example, the leftward movement will be explained in detail. The function returns an integer to indicate whether a move is valid or invalid. Initially, `valid_move` is set to 0 and will be updated if any element in any row moves left at least once. For a leftward move, the function loops through all rows, starting from the first column. If the element in the first column is zero, no movement can occur, so the loop continues to the right until a non-zero element is found, checking if it can be moved left. If a non-zero element is encountered, it is stored in an auxiliary variable to assess whether the move resulted in a merge or simply shifted the element past zeros. The function checks if the element to the left is either zero or equal to the current element. If either condition is met, the current element is added to the element on the left, the current position is reset to zero, and the process repeats for subsequent columns. After the final possible merge, if the variable `j` is on a non-zero position, it is incremented to avoid an infinite loop. If the final element resulting from the move differs from the original, the score is increased to reflect the merge.

The "initialize_colors" function creates all the necessary colors and color pairs using RGB values. The "display_board" function is called each time the board is modified, either in the game copy (for undo purposes) or on the actual game board. Arrays for values and colors are created, with each element corresponding to a number in the value array and its associated color in the color array. For each matrix element, a `WINDOW` (cell) is created and colored based on the number at that position. To determine the correct color, the position on the board is compared to the value array, and once the matching position is found, the background is colored using the color at the corresponding position in the color array (as the value and color arrays are correlated).

The "validate" function checks after every move whether there is a winner or if the game is over. First, it checks if there is at least one zero on the board, as this means that further moves are possible, and no additional checks are required. If a 2048 tile is present, the game exits with `winner = 1`. If all tiles are filled, the function verifies whether a valid move can still be made (using the movement algorithms). If any valid move (left, right, up, or down) is possible, the loop exits, as no further checks are necessary. If no valid moves remain, the function returns 1 (game over).

The menu displays three options on the screen, and using the arrow keys, the `highlight` variable is updated. Depending on the variable's value, the selected option is highlighted. However, if "Resume" is chosen at the start, and no previous game exists, this option will not be executed.

In the "auto_move" function, a mask of the board is created every time no key is pressed within 8 seconds. Once the mask is generated, each possible move is simulated, and a frequency array with four elements is updated: 0 - move left, 1 - move right, 2 - move up, 3 - move down. At the end, the move that results in the most empty tiles is selected as the optimal move.

In the "new_game_interface," the initial board is displayed with two randomly generated values, and the corresponding moves are made using the arrow keys. After each move, a check is performed to see if further moves can be made or if a 2048 tile has been achieved. If these conditions are met, the score is saved and displayed in the next round. If 'q' is pressed, the game assumes a resume will be chosen later, and the board matrix is saved to a file in case a resume is needed.

The "resume_interface" is similar to the previous function, with the distinction that here the matrix is read from a saved file, which was created earlier when 'Q' was pressed. This function cannot be accessed if no saved matrix exists in the file.

### Bonuses:

- **Color Variation by Value**: Different colors are assigned to tiles based on their value (as explained earlier).
- **Undo**: A copy of the matrix and score is saved before each move. When 'Z' is pressed, the matrix and score are restored to their previous state.
- **Leaderboard**: In the "username" function, a username is input via the keyboard and stored in a file along with the final score after a win or loss. At first, when no score is available, nothing is displayed. However, once a player and score are saved, they are displayed on the screen. The usernames and scores are stored in a file. In the "leaderboard" function, a struct is created, sorted in descending order, and the top 10 scores are displayed, or fewer if less than 10 exist.
